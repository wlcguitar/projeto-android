@charset "UTF-8";

@import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');

@font-face {
    font-family: 'android';
    src: url(../fonts/idroid.otf) format('opentype');
    font-weight: normal;
}

:root {
    --cor0: #c5ebd6;
    --cor1: #83e1ad;
    --cor2: #3ddc84;
    --cor3: #2fa866;
    --cor4: #1a5c37;
    --cor5: #063d1e;

    --font-padrao: Arial, Verdana, Helvetica, sans-serif;
    --font-destaque: 'Bebas Neue', cursive;
    --font-android: 'android', cursive;
}

* {
    padding: 0px;
    margin: 0px;
}

body {
    background-color: var(--cor0);
    font-family: var(--font-padrao);
}

header {
    background-image: linear-gradient(to bottom, var(--cor3), var(--cor5));
    min-height: 150px;
    text-align: center;
    padding-top: 40px;
}

header > h1 {
    color: white;
    font-family: var(--font-destaque);
    font-size: 3em;
    font-weight: normal;
    margin-bottom: 18px;
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.285);
}

header > p {
    font-family: var(--font-padrao);
    font-size: 1.2em;
    color: white;
    max-width: 600px;
    padding-left: 10px;
    padding-right: 10px;
    margin: auto;
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.299);
}

nav {
    background-color: var(--cor5);
    padding: 10px;
    box-shadow: 0px 7px 7px rgba(0, 0, 0, 0.199);
}

nav > a {
    color: var(--cor0);
    padding: 10px;
    text-decoration: none;
    font-weight: bold;
    border-radius: 5px;
}

nav > a:hover {
    background-color: var(--cor3);
    color: var(--cor5);
}

main {
    background-color: white;
    margin: auto;
    margin-bottom: 30px;
    min-width: 300px;
    max-width: 950px;
    padding: 20px;
    box-shadow: 0 0 10px  rgba(0, 0, 0, 0.42);
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
}

main h1 {
    font-family: var(--font-android);
    color: var(--cor5);
    font-weight: normal;
    font-size: 1.8em;
}

main h2 {
    font-family: var(--font-android);
    color: var(--cor4);
    font-size: 1.3em;
    font-weight: normal;
    background-image: linear-gradient(to right, var(--cor1), transparent); 
    text-indent: 8px;
}

main p {
    margin: 15px 0px;
    text-align: justify;
    text-indent: 30px;
    font-size: 1em;
    line-height: 1.5em;
}


main img {
    width: 100%;
}

main strong {
    color: var(--cor5);
}

main a {
    color: var(--cor5);
    padding: 5px 0px;
    font-weight: bold;
    text-decoration: none;
}

main a:hover {
    color: var(--cor3);
}

main a::after {
    content: '\1f517';
}

img.bugdroid__img {
    display: block;
    margin: auto;
    max-width: 350px;
}

div.video {
    background-color: var(--cor4);
    margin-bottom: 30px;
    margin: 0px -20px 30px -20px;
    padding: 20px;
    padding-bottom: 57%;
    position: relative;
}

div.video > iframe {
    position: absolute;
    top: 5%;
    left: 5%;
    width: 90%;
    height: 90%;
}

aside {
    background-color: var(--cor1);
    padding: 10px;
    border-radius: 10px;
    box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.279);
}

aside > h3 {
    background-color: var(--cor4);
    color: white;
    padding: 10px;
    margin: -9px -9px 0px -9px;
    border-radius: 10px 10px 0px 0px;
}

aside  > ul {
    list-style-position: inside;
    list-style-type: '\2714\00A0\00A0';
    columns: 2;
}

footer {
    background-color: var(--cor5);
    color: white;
    text-align: center; 
    font-size: 1em;
    padding: 10px;
}

footer strong {
    color: var(--cor3);
}

/* Quando devemos usar o sinal de maior ( " > " ) para manipular elementos que estão dentro de outros elementos (filho/children)? Talvez alguns de vocês estejam na dúvida, porque tem vezes que o Guanabara usa o sinal, e outras não... E às vezes, quando inserimos o sinal nos nossos seletores, as declarações simplesmente não tem efeito...

ESCLARECENDO:

Nesse caso, você precisa lembrar dos conceitos de COMBINADORES DE SELETORES, que nada mais é do que criar uma relação útil entre os seletores. 

Você usa o " > " quando quer indicar que deseja estilizar um FILHO DIRETO de um elemento. Segue um exemplo:

<header>
	<h1></h1>
	<p></p>
</header>

No caso do exemplo acima, o "p" é um filho direto da div especial <header>, e portanto é um elemento de Primeiro Nível. Da mesma forma, veja que o "h1" identicamente é um filho direto de header e portanto é um elemento de Primeiro Nível também. É como se <p> e <h1> fossem IRMÃOS. 

Mas quando você NÃO USA o " > ", você  quer indicar os elementos que não são necessariamente filhos, mas são DESCENDENTES. Veja outro exemplo: 

<main>
	<article>
		<h1></h1>
	</article>
</main>

SELETOR NÃO SIMPLIFICADO PARA O EXEMPLO ACIMA: " main > article > h1 {...} ". H1 é filho direto de article, que é filho direto de main. 

Tem como simplificar? Sim. Nesse caso, perceba que h1 é descendente de main (como se fosse um NETO ), então você pode DEIXAR DE USAR o " > " sem problema nenhum, dessa forma estará indicando elementos que não são necessariamente filhos, e sim descendentes. Exemplo: 

MESMO SELETOR ANTERIOR, SÓ QUE SIMPLIFICADO: " main h1 {...} "

Obs.: Se tivéssemos criado o seletor simplificado do exemplo acima, mas com o sinal " > " ( ex: main > h1 {...} ), não funcionaria porque esse h1 NÃO É FILHO DIRETO do main, e sim neto. Sendo que o sinal de maior ( ">" ) serve apenas para indicar filhos diretos.

É por isso que o Guanabara não usa o sinal de maior (>) às vezes, ele está simplificando o seletor (quando possível).

Isso facilita muito, porque você não precisará de uma pancada de classes e deixa o seu código mais limpo. */

/*
PROPRIEDADES DE ESTILO PARA LISTAS:

Segue algumas Propriedades de Estilo extras apresentadas no vídeo para usarmos dentro de seletores de listas ( ex.: ul {...} ):

Quando criamos uma lista dentro de outro elemento, dentro de um aside por exemplo, geralmente as "bolinhas" da lista (marcadores sequenciais no caso de listas ordenadas) irão ficar para fora do elemento pai (aside)... Para resolver isso e manter a lista inteira dentro do elemento pai, devemos utilizar a Propriedade de Estilo " list-style-position " com o valor " inside " (por padrão marcadores de listas são posicionados com o valor " outside "). Essa propriedade define a posição dos marcadores da lista e dessa forma as "bolinhas" ficarão para dentro do elemento pai.

Outra questão, às vezes temos uma lista com muitos itens, muito extensa... E queremos dividi-la em duas partes para manter uma formatação mais agradável... Para fazer isso, temos a Propriedade de Estilo " columns " com o valor " 2 ". Com isso iremos dividir a nossa lista em duas colunas (se quiser dividir em mais de duas colunas é só alterar o valor numérico da propriedade).

É possível trocar as "bolinhas" ou marcadores de listas por outro símbolo, um emoji por exemplo. Para fazer isso, devemos usar a Propriedade de Estilo " list-style-type "... Como valor dessa propriedade, devemos colocar entre aspas 'simples' o número do código do emoji que escolhermos (sem o "U+"), e após isso, para de fato carregar o emoji, adicionar uma contrabarra ( \ ) antes do código do emoji e ainda dentro das aspas 'simples'. Obs.: A troca de símbolos de lista não é 100% compatível com todos os navegadores.

Uma coisa que pode acontecer é o nosso símbolo ficar "grudado" no item da lista, para evitar isso é indicado acrescentar um "espaço" entre o emoji e o item de lista. Para fazer isso, ainda dentro das aspas 'simples' e DEPOIS do código do emoji, acrescente outra contrabarra ( \ ) e logo após isso o código " 00A0 " ou " 0020 " (comando de espaço ). Se você quiser, pode inserir mais de um espaço, é só repetir o processo. Obs.: Sempre que você quiser dar um "espaço" ou inserir emojis pelo CSS, para qualquer outro elemento e não somente listas, faça como foi orientado nesse texto. 

Exemplo geral:

ul {
    list-style-position: inside;
    columns: 2;
    list-style-type: '\1F5F8\00A0\00A0';
}

Nota: Ainda existem muitas outras Propriedades de Estilo para listas além dessas três apresentadas no vídeo e descritas nesse texto.

MARGIN NEGATIVA:

No nosso projeto, dentro da área " Saiba Mais " (aside), formatamos o nosso h3 de um jeito que parece que o subtítulo faz parte do topo da caixa. Para fazer isso, inicialmente atribuímos um destaque de cores ao subtítulo e adicionamos um pequeno padding de 10px no mesmo... 

O resultado desejado seria que a caixa do h3 crescesse para "fora" e ocupasse a exata forma do topo da caixa do aside, resultando no efeito descrito.

Para isso, configuramos as margins laterais e superior do nosso h3 com um valor negativo de -10px, dessa forma a caixa do h3 irá crescer para "fora" e ocupará a forma do topo da caixa aside. A margin (espaçamento externo) foi configurada com um valor negativo, na prática essa margin está indo para dentro e se expandindo de forma inversa, abrangendo o topo do aside. Uma mesma configuração com um valor positivo no margin não daria o mesmo efeito.

Para fechar, posteriormente é só fazer o arredondamento da parte de cima da caixa do h3, para ficar condizente com a parte inferior da nossa caixa aside.

*/